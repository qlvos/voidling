<!DOCTYPE html>
<html>

<head>
  <title>voidling v0.9 - Optimized</title>
  <style>
    body {
      tab-size: 2;
      background-color: #252525;
      color: #fff;
      margin: 0;
      font-family: monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      /* Add this */
      height: 100vh;
    }

    pre {
      tab-size: 2;
      margin: 0;
      white-space: pre;
      font-size: var(--voidling-font-size, 12px);
      line-height: 1;
    }

    a {
      text-decoration: none;
      color: inherit;
    }

    .container {
      border: 1px solid white;
      flex: 1;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      height: 100%;
      z-index: 0;
      background-color: transparent;
    }

    #output {
      white-space: pre;
      font-size: var(--voidling-font-size, 12px);
      line-height: 1;
      z-index: 2;
      background-color: transparent;
    }

    .c57 {
      background-color: #252525;
      color: #5f00ff;
    }

    .c99 {
      background-color: #252525;
      color: #875fff;
    }

    .c105 {
      background-color: #252525;
      color: #8787ff;
    }

    .c166 {
      background-color: #252525;
      color: #d75f00;
    }

    .c208 {
      background-color: #252525;
      color: #ff8700;
    }

    .c141 {
      background-color: #252525;
      color: #af87ff;
    }

    .c57:hover {
      cursor: pointer;
    }

    .c166:hover {
      cursor: pointer;
    }

    .c99:hover {
      cursor: pointer;
    }

    .c141:hover {
      cursor: pointer;
    }

    .portfolio {
      tab-size: 2;
      position: absolute;
      background-color: transparent;
      color: lightgray;/*#554d64;*/
      z-index: 0;
      display: flex;
      flex-direction: column;
      padding: 0;
      /* Change from 20px to 0 */
      overflow: hidden;
      /* Change from auto to hidden */
      width: fit-content;
      /* Add this */
      height: fit-content;
      /* Add this */
    }

    .voidling {
      position: absolute;
      background-color: transparent;
      color: lightgray;
      z-index: 1;
      text-align: right;
      display: flex;
      flex-direction: column;
      padding: 0;
      /* Change from 20px to 0 */
      overflow: hidden;
      /* Change from auto to hidden */
      width: fit-content;
      /* Add this */
      height: fit-content;
      /* Add this */
    }

    .catbox {
      position: absolute;
      bottom: 0;
      width: 100%;
    }

    .assetboxclass {
      display: block;
      margin: 0px 0;
      white-space: pre-wrap;
      /*color: lightgray;*/
    }

    #investmentheader {
      display: block;
      margin-top: 0px;
      color: lightgray;
    }

    .asset {
      margin: 0px 0;
      padding-left: 0px;
    }
  </style>
</head>

<body>

  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="./prophecies.js"></script>
  <script src="./voidling-config-agitated.js"></script>
  <script src="./voidling-config-cautious.js"></script>
  <script src="./voidling-config-curious.js"></script>
  <script src="./voidling-config-excited.js"></script>
  <script src="./voidling-config-serene.js"></script>
  <script src="./voidling-config-mob.js"></script>

  <div class="container">
    <pre id="output"></pre>
    <div id="portfoliobox" class="portfolio">
      <div>
        <pre>
        voidling portfolio
        <span id="assetbox" class="assetboxclass"></span>
        <span id="investmentheader"></span>
        <span id="investmentbox" class="assetboxclass"></span>
        voidling index
        <span id="watchlistbox" class="assetboxclass">
        </span>
        </pre>
      </div>
    </div>
    <div id="voidlingbox" class="voidling">
    </div>
  </div>

  <script>
    // Mobile detection setup
    window.isMobile = window.innerWidth <= 999;  // Using 999 like in the working version
    let lastMobileState = window.isMobile;

    function checkMobile() {
      window.isMobile = window.innerWidth <= 999;  // Using 999 like in the working version
      if (lastMobileState !== window.isMobile) {
        lastMobileState = window.isMobile;
        return true;
      }
      return false;
    }

    checkMobile();
    console.log('Initial mobile state:', window.isMobile);

    function updateVoidlingSize() {
      document.documentElement.style.setProperty('--voidling-font-size',
        window.isMobile ? '24px' : '12px'
      );
      console.log('Font size updated to:', window.isMobile ? '24px' : '12px');
    }

    updateVoidlingSize();

    checkMobile();
    console.log('Initial mobile state:', window.isMobile);

    function updateVoidlingSize() {
      document.documentElement.style.setProperty('--voidling-font-size',
        window.isMobile ? '24px' : '12px'
      );
    }

    updateVoidlingSize();

    let emotion;
    let currentRadius = null;
    let lastTextChange = Date.now();
    let text = '';
    const assetBoxId = "assetbox";
    const watchlistBoxId = "watchlistbox";

    const scrollSettings = new Map();
    scrollSettings.set(assetBoxId, { top: 1, size: 3 } )
    scrollSettings.set(watchlistBoxId, { top: 1, size: 3 } )
    

    // portfolio box offset compared to the voidling square
    const PORTFOLIO_OFFSET_TOP = 1.8;
    const PORTFOLIO_OFFSET_LEFT = 1.2;

    const PORTFOLIO_OFFSET_TOP_MOBILE = 2.5;
    const PORTFOLIO_OFFSET_LEFT_MOBILE = 1.2;

    // Configuration constants
    const FRAME_INTERVAL = 48;
    const FRAME_HISTORY_SIZE = 48;
    const CLEANUP_INTERVAL = 1200;
    const MEMORY_THRESHOLD_MB = 200;
    const MAX_POOL_SIZE = 6;
    const MEMORY_CHECK_INTERVAL = 1000;
    const MAX_FRAME_BUFFER_SIZE = 24;  // Maximum number of frames to keep
    const BUFFER_POOL_CLEANUP_INTERVAL = 100;  // Clean pool every N frames

    // Color mapping
    const colorMap = {
      '.': 'c57', ',': 'c57', '-': 'c99',
      '~': 'c99', ':': 'c99', ';': 'c105',
      '=': 'c105', '!': 'c105', '*': 'c105',
      '#': 'c166', '@': 'c208', '$': 'c141'
    };

    let assetBoxHover = false;

    function manageMouseOver(box) {
      const rect = box.getBoundingClientRect();     
      const x = event.clientX;
      const y = event.clientY;
      if(x > rect.left && x < (rect.left+rect.width) && y > rect.top && y < (rect.top+rect.height)) {
        let pbox = document.getElementById("portfoliobox");
        assetBoxHover = true;
        pbox.style.zIndex='10';
        return true;
      } else {
        if(assetBoxHover) {
          let pbox = document.getElementById("portfoliobox");
          pbox.style.zIndex='0';
          assetBoxHover = false;
        }
      }
    }
  
    document.addEventListener('mousemove', (event) => {
      manageMouseOver(document.getElementById(assetBoxId)) ||
      manageMouseOver(document.getElementById(watchlistBoxId))
    });
 

    // Circular buffer for frame management
    class CircularFrameBuffer {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.buffer = new Array(maxSize);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
      }

      push(frame) {
        if (this.size === this.maxSize) {
          if (this.buffer[this.tail]) {
            bufferPool.return(this.buffer[this.tail]); // Return old buffer to the pool
          }
          this.tail = (this.tail + 1) % this.maxSize;
          this.size--;
        }

        this.buffer[this.head] = frame;
        this.head = (this.head + 1) % this.maxSize;
        this.size++;
      }

      get(index) {
        if (index >= this.size) return null;
        return this.buffer[(this.tail + index) % this.maxSize];
      }

      clear() {
        while (this.size > 0) {
          if (this.buffer[this.tail]) {
            bufferPool.return(this.buffer[this.tail]); // Return to pool
          }
          this.buffer[this.tail] = null; // Clear reference
          this.tail = (this.tail + 1) % this.maxSize;
          this.size--;
        }
        this.head = 0;
        this.tail = 0;
      }
    }

    // Optimized buffer pool
    class OptimizedBufferPool {
      constructor(maxPoolSize) {
        this.pools = new Map();
        this.maxPoolSize = maxPoolSize;
        this.totalBuffers = 0;
      }

      get(size) {
        if (!this.pools.has(size)) {
          this.pools.set(size, []);
          console.log('Created new pool for size:', size);
        }

        const pool = this.pools.get(size);
        if (pool.length > 0) {
          this.totalBuffers--;
          return pool.pop();
        }

        return new Uint8Array(size);
      }

      return(buffer) {
        const size = buffer.length;
        if (!this.pools.has(size)) {
          this.pools.set(size, []);
        }

        const pool = this.pools.get(size);
        if (pool.length < this.maxPoolSize && this.totalBuffers < this.maxPoolSize * 2) {
          pool.push(buffer);
          this.totalBuffers++;
        }
      }

      cleanup() {
        for (const [size, pool] of this.pools) {
          while (pool.length > Math.min(3, this.maxPoolSize / 4)) {
            pool.pop(); // Remove excess buffers
            this.totalBuffers--;
          }
        }
      }
    }

    // Global variables
    let lastMemoryCheck = 0;
    let isTabVisible = true;
    let frameCounter = 0;
    let lastFrameTime = 0;
    let outputElement;
    let bufferArray = new Uint8Array(0);
    let resizeTimeout;
    let isRunning = true; // Flag to control animation frames

    const frameBuffer = new CircularFrameBuffer(FRAME_HISTORY_SIZE);
    const bufferPool = new OptimizedBufferPool(MAX_POOL_SIZE);

    function bufferToHTML(buffer, width) {
      let html = '';
      const topText = " HERE IS THE VOIDLING'S REALM ";
      const rightText = " DO NOT DISTURB IT ";
      const bottomText = " WITHIN THESE BOUNDARIES ";
      const leftText = " IT LIVES AND EVOLVES ";

      const topColor = 'c208';
      const rightColor = 'c99';
      const bottomColor = 'c208';
      const leftColor = 'c105';

      for (let i = 0; i < buffer.length; i++) {
        const row = Math.floor(i / width);
        const col = i % width;
        let char = String.fromCharCode(buffer[i]);
        let customColor = null;

        // Calculate center positions
        const topStart = Math.floor((width - topText.length) / 2);
        const bottomStart = Math.floor((width - bottomText.length) / 2);
        const height = Math.floor(buffer.length / width);
        const leftStart = Math.floor((height - leftText.length) / 2);
        const rightStart = Math.floor((height - rightText.length) / 2);

        // Top border centered text
        if (row === 0 && col >= topStart && col < topStart + topText.length) {
          char = topText[col - topStart];
          customColor = topColor;
        }
        // Bottom border centered text
        else if (row === height - 1 && col >= bottomStart && col < bottomStart + bottomText.length) {
          char = bottomText[col - bottomStart];
          customColor = bottomColor;
        }
        // Left border centered text
        else if (col === 0 && row >= leftStart && row < leftStart + leftText.length) {
          char = leftText[row - leftStart];
          customColor = leftColor;
        }
        // Right border centered text
        else if (col === width - 1 && row >= rightStart && row < rightStart + rightText.length) {
          char = rightText[row - rightStart];
          customColor = rightColor;
        }

        const colorClass = customColor || colorMap[char];
        html += colorClass ?
          `<span id="${i}" class="${colorClass}">${char}</span>` : char;
        if ((i + 1) % width === 0) html += '\n';
      }
      return html;
    }

    function buffersEqual(a, b) {
      if (!a || !b || a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function calculateDimensions() {
      try {
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        const charWidth = window.isMobile ? 14 : 7;
        const charHeight = window.isMobile ? 24 : 12;
        const paddingPercent = 0.1;

        const paddingMultiplier = window.isMobile ? 0.4 : 1.15;

        const maxWidth = Math.floor((vw * (1 - paddingPercent * 1.15)) / charWidth);
        const maxHeight = Math.floor((vh * (1 - paddingPercent * paddingMultiplier)) / charHeight);

        return {
          width: Math.max(50, Math.min(maxWidth, window.isMobile ? 200 : 400)),
          height: Math.max(10, Math.min(maxHeight, window.isMobile ? 100 : 200))
        };

      } catch (e) {
        console.error('Dimension calculation failed:', e);
        return { width: 190, height: 61 };
      }
    }

    function preserveVoidlingState() {
      // Function body unchanged
     
      const complexity = Module._get_deform_complexity();
      const deformPhases = [];
      const deformFreqs = [];

      for (let i = 0; i < complexity; i++) {
        deformPhases.push(Module.ccall('get_deform_phase', 'number', ['number'], [i]));
        deformFreqs.push(Module.ccall('get_deform_freq', 'number', ['number'], [i]));
      }
      

      return {
        position: {
          movementX: Module.ccall('get_movement_x', 'number', [], []),
          movementY: Module.ccall('get_movement_y', 'number', [], []),
          targetX: Module.ccall('get_target_x', 'number', [], []),
          targetY: Module.ccall('get_target_y', 'number', [], []),
          lastTargetX: Module.ccall('get_last_target_x', 'number', [], []),
          lastTargetY: Module.ccall('get_last_target_y', 'number', [], [])
        },
        rotation: {
          rotX: Module.ccall('get_rot_x', 'number', [], []),
          rotY: Module.ccall('get_rot_y', 'number', [], []),
          rotZ: Module.ccall('get_rot_z', 'number', [], []),
          targetRotX: Module.ccall('get_target_rot_x', 'number', [], []),
          targetRotY: Module.ccall('get_target_rot_y', 'number', [], []),
          targetRotZ: Module.ccall('get_target_rot_z', 'number', [], []),
          rotationSpeed: Module.ccall('get_rotation_speed', 'number', [], [])
        },
        behavior: {
          current: Module.ccall('get_current_behavior', 'number', [], []),
          timer: Module.ccall('get_behavior_timer', 'number', [], []),
          stuckCounter: Module.ccall('get_stuck_counter', 'number', [], []),
          horizontalPersistenceTimer: Module.ccall('get_horizontal_persistence_timer', 'number', [], [])
        },
        deformation: {
          complexity: complexity,
          phases: deformPhases,
          frequencies: deformFreqs
        },
        time: Module.ccall('get_current_time', 'number', [], [])
      };
    }

    function restoreVoidlingState(state) {
      // Function body unchanged
      Module.ccall('set_movement_x', null, ['number'], [state.position.movementX]);
      Module.ccall('set_movement_y', null, ['number'], [state.position.movementY]);
      Module.ccall('set_target_x', null, ['number'], [state.position.targetX]);
      Module.ccall('set_target_y', null, ['number'], [state.position.targetY]);

      Module.ccall('set_rot_x', null, ['number'], [state.rotation.rotX]);
      Module.ccall('set_rot_y', null, ['number'], [state.rotation.rotY]);
      Module.ccall('set_rot_z', null, ['number'], [state.rotation.rotZ]);

      Module.ccall('set_current_behavior', null, ['number'], [state.behavior.current]);
      Module.ccall('set_current_time', null, ['number'], [state.time]);

      if (state.deformation) {
        for (let i = 0; i < state.deformation.complexity; i++) {
          if (i < state.deformation.phases.length) {
            Module.ccall('set_deform_phase', null, ['number', 'number'], [i, state.deformation.phases[i]]);
          }
          if (i < state.deformation.frequencies.length) {
            Module.ccall('set_deform_freq', null, ['number', 'number'], [i, state.deformation.frequencies[i]]);
          }
        }
      }
    }

    function checkMemoryUsage() {
      if (performance.memory) {
        const memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024);
        if (memoryUsage > MEMORY_THRESHOLD_MB) {
          console.warn(`High memory usage: ${memoryUsage.toFixed(2)}MB`);
          forceCleanup();
        }
      }
    }

    function initVoidlingConfig() {
      console.log("init cfg " + emotion)

      let cfg = voidlingConfigSerene;
      if(emotion) {
        if(emotion == "EXCITED") {
          cfg = voidlingConfigExcited;
        } else if (emotion == "CURIOUS") {
          cfg = voidlingConfigCurious;
        } else if (emotion == "CAUTIOUS") {
          cfg = voidlingConfigCautious;
        } else if (emotion == "AGITATED") {
          cfg = voidlingConfigAgitated;
        }
      }

      if(window.isMobile) {
        cfg = voidlingConfigVanilla;
      }

      Module._initVoidlingWithConfig(
        cfg.baseRadius,
        cfg.aspectRatio,
        cfg.moveSpeed,
        cfg.moveChangeFrequency,
        cfg.minRotationSpeed,
        cfg.maxRotationSpeed,
        cfg.rotationSmoothness,
        cfg.maxRotationAngle,
        cfg.baseDeformStrength,
        cfg.extraDeformStrength,
        cfg.deformFrequency,
        cfg.drippiness,
        cfg.deformComplexity,
        cfg.timeSpeed,
        cfg.perspectiveDistance,
        cfg.perspectiveStrength,
        cfg.stepSize,
        cfg.fillDensity,
        cfg.maxMoveDistance,
        cfg.borderSquishFactor,
        cfg.minSkewness,
        cfg.minMoveDistance,
        cfg.behaviorChangeTime,
        cfg.behaviorWeight,
        cfg.deformSmoothness,
        cfg.xBias,
        cfg.yBias,
        cfg.maxHorizontalPersistence
      );
    }

    function forceCleanup() {
      // Clear frame buffer and return all buffers to the pool
      frameBuffer.clear();

      // Cleanup WebAssembly resources if available
      if (Module && Module._cleanup) {
        try {
          const state = preserveVoidlingState(); // Preserve the current state
          Module._cleanup(); // Call WebAssembly cleanup function

        // Reinitialize the Voidling with its configuration
        if (window.VoidlingConfig) {
          initVoidlingConfig();
          const dims = calculateDimensions();

          Module._set_dimensions(dims.width, dims.height);
          restoreVoidlingState(state); // Restore the previous state
        }
          
        } catch(err) {
          console.log(err)
        }

      }

      // Cleanup buffer pool
      bufferPool.cleanup();

      // Clear DOM content
      if (outputElement) {
        outputElement.innerHTML = ''; // Ensure DOM is completely reset
      }

      // Reset global variables
      bufferArray = new Uint8Array(0); // Clear buffer reference
      frameCounter = 0;
      lastFrameTime = 0;

      // Log cleanup status for debugging
      console.log('forceCleanup: All buffers cleared, WebAssembly state reset.');
    }

    window.addEventListener('resize', function () {
      if (resizeTimeout) {
        cancelAnimationFrame(resizeTimeout);
      }

      resizeTimeout = requestAnimationFrame(() => {
        try {
          const wasMobile = window.isMobile;
          checkMobile();
          console.log('Resize detected, window width:', window.innerWidth);

          if (wasMobile !== window.isMobile) {
            console.log('Mobile state changed:', window.isMobile);
            updateVoidlingSize();
            forceCleanup();
          }

          const dims = calculateDimensions();
          if (Module && Module._set_dimensions) {
            Module._set_dimensions(dims.width, dims.height);
          }
        } catch (e) {
          console.error('Resize handling failed:', e);
        }
      });
    });

    document.addEventListener('DOMContentLoaded', function () {
      checkMobile();
      updateVoidlingSize();
    });

    var Module = {
      onRuntimeInitialized: function () {
        try {
          outputElement = document.getElementById('output');

          if (!outputElement) throw new Error('Output element not found');

          Module._initialize_trig_cache();

          const loadConfig = () => {
            /*
            return new Promise((resolve) => {
              const configScript = document.createElement('script');
              configScript.src = window.isMobile ? 'voidling-config-mob.js' : 'voidling-config.js';

              configScript.onload = () => {
                console.log('Config loaded successfully');
                setTimeout(() => resolve(), 100);
              };

              configScript.onerror = (e) => {
                console.error('Config loading failed:', e);
                resolve();
              };

              document.body.appendChild(configScript);
            });
            */
          };

          const initializeVoidling = async () => {
            await loadConfig();

            //if (!window.VoidlingConfig) {
            //  throw new Error('Config not loaded properly');
            //}


            initVoidlingConfig();

            const dims = calculateDimensions();
            Module._set_dimensions(dims.width, dims.height);

            function updateDisplay(timestamp) {

              let offsetTop = window.isMobile ? PORTFOLIO_OFFSET_TOP_MOBILE : PORTFOLIO_OFFSET_TOP;
              let offsetLeft = window.isMobile ? PORTFOLIO_OFFSET_LEFT_MOBILE : PORTFOLIO_OFFSET_LEFT;
              document.getElementById('portfoliobox').style.top = `${outputElement.offsetTop * offsetTop * 1.4}px`;
              document.getElementById('portfoliobox').style.left = `${outputElement.offsetLeft * offsetLeft}px`;

              document.getElementById('voidlingbox').style.top = `${outputElement.offsetTop * offsetTop}px`;
              document.getElementById('voidlingbox').style.width = `${outputElement.offsetWidth * 0.95}px`;
              
              if (!isRunning) return; // Stop the loop if not running
              if (!isTabVisible || timestamp - lastFrameTime < FRAME_INTERVAL) {
                requestAnimationFrame(updateDisplay);
                return;
              }

              const now = Date.now();
              if (now - lastMemoryCheck > MEMORY_CHECK_INTERVAL) {
                checkMemoryUsage();
                lastMemoryCheck = now;
              }

              lastFrameTime = timestamp;

              if (frameCounter % CLEANUP_INTERVAL === 0) {
                forceCleanup();
                if (typeof window.gc === 'function') {
                  try {
                    window.gc();
                  } catch (e) {
                    console.log('Manual GC not available');
                  }
                }
              }

              try {
                Module._animationFrame();

                const bufferPtr = Module._getBuffer();
                const bufferSize = Module._getBufferSize();

                if (bufferArray.length !== bufferSize) {
                  bufferArray = new Uint8Array(Module.HEAPU8.buffer, bufferPtr, bufferSize);
                } else {
                  bufferArray.set(Module.HEAPU8.subarray(bufferPtr, bufferPtr + bufferSize));
                }

                const newBuffer = bufferPool.get(bufferSize); // Get a reusable buffer
                newBuffer.set(Module.HEAPU8.subarray(bufferPtr, bufferPtr + bufferSize));

                const lastFrame = frameBuffer.get(0);
                if (!lastFrame || !buffersEqual(newBuffer, lastFrame)) {
                  frameBuffer.push(newBuffer); // Push the new frame
                  const html = bufferToHTML(newBuffer, dims.width);
                  if (outputElement.innerHTML !== html) {
                    outputElement.innerHTML = html; // Update DOM only if necessary

                    let watchBrain = true;
                    if(watchBrain) {
                      const elementIds = Object.values(colorMap);
                    let uniqueElementIds = new Set(elementIds);
                    let elements = [];
                    for (const id of uniqueElementIds) {
                      elements.push(...document.querySelectorAll("." + id))
                    }

                   // elements = elements.sort((a, b) => {
                   //   return a.id - b.id
                   // })

                    let length = 60;

                    let now = Date.now();
                    let minTextKeep = 500;
                    elements.forEach((element, index) => {
                      element.addEventListener('mouseover', () => {
                        //Module._set_move_speed(0.0001);
                        //window.VoidlingConfig.moveSpeed = 0.0001;
                        //Module._set_move_speed=0.0001;

                        
                        //window.VoidlingConfig.baseRadius = currentRadius;

                        let counter = 0;
                        for (let i = Math.max(0, index - length); i <= Math.min(elements.length - 1, index + length); i++) {
                          //console.log(elements[i])
                          elements[i].style.color = "#FFFFFF";
                          elements[i].style.cursor = "pointer";

                          if (counter >= (length * 2)) {
                            break;
                          }

                          let char = prophecies.charAt(Math.min(i, prophecies.length))
                          elements[i].innerHTML = char;
                          elements[i].classList.add('hovered');
                          ++counter;
                        }
                      });

                      element.addEventListener('mouseout', () => {
                        for (let i = Math.max(0, index - length); i <= Math.min(elements.length - 1, index + length); i++) {
                          elements[i].classList.remove('hovered');
                        }
                      });
                    });
                    }
                  }
                } else {
                  bufferPool.return(newBuffer); // Return unused buffer to pool
                }

                frameCounter++;
                if (frameCounter % BUFFER_POOL_CLEANUP_INTERVAL === 0) {
                  bufferPool.cleanup();
                }
              } catch (e) {
                console.error('Frame update failed:', e);
              }

              requestAnimationFrame(updateDisplay);
            }
            requestAnimationFrame(updateDisplay);
          };

          initializeVoidling().catch(e => {
            console.error('Initialization failed:', e);
            outputElement.innerHTML = 'Failed to initialize voidling. Please refresh the page.';
          });

        } catch (e) {
          console.error('Setup failed:', e);
          outputElement.innerHTML = 'Failed to initialize voidling. Please refresh the page.';
        }

        // Expose the cleanup function
        Module._cleanup = Module.cwrap('cleanup', null, []);
        Module._initVoidlingWithConfig = Module.cwrap('initVoidlingWithConfig', null, [
          'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number',
          'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number',
          'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number',
          'number', 'number', 'number'
        ]);
        Module._set_dimensions = Module.cwrap('set_dimensions', null, ['number', 'number']);
        Module._animationFrame = Module.cwrap('animationFrame', null, []);
        Module._getBuffer = Module.cwrap('getBuffer', 'number', []);
        Module._getBufferSize = Module.cwrap('getBufferSize', 'number', []);
        Module._initialize_trig_cache = Module.cwrap('initialize_trig_cache', null, []);
        Module._get_deform_complexity = Module.cwrap('get_deform_complexity', 'number', []);
        console.log("_initialize_trig_cache")
        console.log(Module._initialize_trig_cache)
        console.log("_get_deform_complexity")
        console.log(Module._get_deform_complexity)
      }
    };

    // Event listener functions
    function onVisibilityChange() {
      isTabVisible = !document.hidden;
      if (document.hidden) {
        forceCleanup();
        if (resizeTimeout) {
          cancelAnimationFrame(resizeTimeout);
          resizeTimeout = null;
        }
      }
    }
    document.addEventListener('visibilitychange', onVisibilityChange);

    function onError(e) {
      if (e.message.includes('wasm')) {
        console.error('WASM loading failed:', e);
        if (outputElement) {
          outputElement.innerHTML = 'Failed to initialize voidling. Please refresh the page.';
        }
      }
    }
    window.addEventListener('beforeunload', function () {
      // Empty handler to prevent bfcache
    });

    window.addEventListener('unload', function () {
      isRunning = false;

      if (Module) {
        if (Module._cleanup) {
          Module._cleanup();
        }
        Module = null;
      }
      frameBuffer.clear();
      bufferPool.cleanup();
      bufferArray = null;
      outputElement = null;

      // Remove event listeners
      document.removeEventListener('visibilitychange', onVisibilityChange);
      window.removeEventListener('resize', onResize);
      window.removeEventListener('error', onError);

      console.log('Page unloaded: all resources released.');
    });

    window.addEventListener('pageshow', function (event) {
      if (event.persisted) {
        console.log('Page was restored from bfcache.');
        // Optionally reload the page to clear memory
        // window.location.reload();
      }
    });

  </script>

  <!-- Include the script without cache-busting -->
  <script>
    function loadVoidlingScript() {
      const voidlingScript = document.createElement('script');
      voidlingScript.src = window.isMobile ? 'voidling-mob.js' : 'voidling.js';
      document.body.appendChild(voidlingScript);
    }
    loadVoidlingScript();
  </script>

  <script>

    let socket;
    let reconnectInterval = 2000;
    let keepAliveInterval = 3000;
    let keepAliveTimer;

    function connectWebSocket() {
      // Open a WebSocket connection
      socket = new WebSocket('ws://localhost:47901/ws');

      // Handle the open event
      socket.onopen = function (event) {
        // Handle incoming messages
        socket.onmessage = function (event) {
          let msg = JSON.parse(event.data);
          if (msg.action == "vdata") {
            if(emotion != msg.emotion) {
              console.log("New emotion!")
              console.log(msg.emotion)
              forceCleanup();
            }
            emotion = msg.emotion;

            document.getElementById("voidlingbox").innerHTML = msg.comment;

            renderAssets(assetBoxId, msg.assets, scrollSettings.get(assetBoxId));
            renderAssets("watchlistbox", msg.watchlist, scrollSettings.get(watchlistBoxId));

            if (msg.latestinvestment && msg.latestinvestment.length > 0 && msg.latestinvestment[0] != null) {
              document.getElementById("investmentheader").innerHTML = "Latest investment";
              renderAssets("investmentbox", msg.latestinvestment);
            }

          } else if (msg.action == "ping") {
            socket.send(JSON.stringify({ action: "pong" }));
          }
        };

        // Handle the close event
        socket.onclose = function (event) {
          console.log('WebSocket connection closed:', event);
          $('#messages').append('<p>WebSocket connection closed</p>');

          // Clear the keepalive timer
          clearInterval(keepAliveTimer);

          // Attempt to reconnect
          setTimeout(connectWebSocket, reconnectInterval);
        };

        // Handle errors
        socket.onerror = function (error) {
          console.error('WebSocket error:', error);
          $('#messages').append('<p>WebSocket error: ' + error.message + '</p>');
        };
      }
    }
    connectWebSocket();
  </script>

  <script>
    const dexScreenerUrl = function (address) {
      return "https://dexscreener.com/solana/" + address;
    }

    function formatAmount(amount) {
      if(amount == null) {
        return null;
      }
      return parseInt(amount, 10).toLocaleString('en-US');
      return amnt < 0 ? ("-" + amnt) : amnt;
    }

    function formatPercentage(variation, ratio) {
      if(variation == null) {
        return null;
      }
      let percentage = ratio ? ((variation * 100) - 100).toFixed(0) : variation.toFixed(0);
      return (percentage > -1 ? "+" : "") + percentage + "%";
    }

    function calculatePaddings(strings, maxLength) {
      return strings.map(str => {
        const paddingNeeded = maxLength - str.length;
        return ' '.repeat(paddingNeeded);
      });
    }

    function shortenIfNeeded(str) {
      let maxlength = 15;
      return (window.isMobile && str.length > maxlength) ? (str.substr(0, 3) + "..." + str.substr(str.length - 3)) : str;
    }

    function shorten(str) {
      return (str.substr(0, 3) + "..." + str.substr(str.length - 3));
    }

    const textGap = "    ";

    function truncateString(str, maxLength) {
      if (str.length > maxLength) {
        return str.slice(0, maxLength) + '...';
      } else {
        return str;
      }
    }

    function renderAssets(containerId, assets, scrollSettings) {
      if (!assets || assets.length == 0) {
        return;
      }
      const container = document.getElementById(containerId);
      container.innerHTML = '';

      let formattedAssets = assets.map((asset) => {
        return {
          token : {
            symbol : asset.token.symbol,
            name : truncateString(asset.token.name, (window.isMobile ? 10 : 20))
          },
          address: shorten(asset.address),
          holdingsUsdValue: formatAmount(asset.holdingsUsdValue),
          priceChange6h: formatPercentage(asset.priceChange6h),
          assetBagValue: formatAmount(asset.assetBagValue),
          variation: formatPercentage(asset.variation)
        }
      });

      let names = formattedAssets.map(asset => asset.token.name);
      const maxNameLength = Math.max(...names.map(name => name.length));
      const namePaddings = calculatePaddings(names, maxNameLength);

      let holdingUsdValues = formattedAssets.map(item => item.holdingsUsdValue);
      let hasHoldingValues = formattedAssets.length > 0 && formattedAssets[0].holdingsUsdValue != null;
      const maxHoldingUsdValueLength = hasHoldingValues ? Math.max(...holdingUsdValues.map(item => item.length)) : null;
      const usdHoldingPaddings = hasHoldingValues ? calculatePaddings(holdingUsdValues, maxHoldingUsdValueLength) : null;

      let priceChange6hValues = formattedAssets.map(item => item.priceChange6h);
      let hasPriceChange6hValues = formattedAssets.length > 0 && formattedAssets[0].priceChange6h != null;
      const max6hValueLength = hasPriceChange6hValues ? Math.max(...priceChange6hValues.map(item => item.length)) : null;
      const priceChangePaddings = hasPriceChange6hValues ? calculatePaddings(priceChange6hValues, max6hValueLength) : null;

      let start = scrollSettings ? (scrollSettings.top-1) : 0;

      let counter = 0;

      const upDiv = document.createElement('div');
      container.appendChild(upDiv)
      if(scrollSettings && scrollSettings.top > 1) {
        upDiv.innerHTML = "<b>^ </b>";
        upDiv.style.cursor = "pointer";

        upDiv.onclick = function() {
          scrollSettings.top=(scrollSettings.top-1);
          renderAssets(containerId, assets, scrollSettings);
        };
        
      } else {
        upDiv.innerHTML = "&nbsp;";
      }


      for (let i=start; i<formattedAssets.length; i++) {

        if(scrollSettings) {
          if(counter >= scrollSettings.size) {
            break;
          }
        }
        ++counter;

        let asset = formattedAssets[i];
        const assetDiv = document.createElement('div');
        assetDiv.className = 'asset';
        assetDiv.innerHTML = `${i+1} ${asset.token.name}${namePaddings[i]} | <a target="_blank" href="${dexScreenerUrl(asset.address)}">${asset.address}</a>`;

        if (asset.holdingsUsdValue != null) {
          assetDiv.innerHTML += ` | $${asset.holdingsUsdValue}`
        }

        if (asset.priceChange6h != null) {
          assetDiv.innerHTML += ` ${usdHoldingPaddings[i]}| ${asset.priceChange6h}${priceChangePaddings[i]} | [6H]`
        }

        if (asset.variation != null) {
          assetDiv.innerHTML += ` | $${asset.bagValue} (${asset.variation})`
        }
        container.appendChild(assetDiv);
      }

      if(scrollSettings) {
        const nextDiv = document.createElement('div');

        if(!((formattedAssets.length > scrollSettings.size) && !((scrollSettings.top) + scrollSettings.size > formattedAssets.length))) {
          nextDiv.innerHTML = "&nbsp;"
          container.appendChild(nextDiv)
          return;
        }

        nextDiv.innerHTML = "<b>v </b>";
        nextDiv.style.cursor = "pointer";

        nextDiv.onclick = function() {
          scrollSettings.top=(scrollSettings.top+1);
          renderAssets(containerId, assets, scrollSettings);
        };
        container.appendChild(nextDiv)
      }

    }
  </script>
</body>

</html>